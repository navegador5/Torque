!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var i=e();for(var s in i)("object"==typeof exports?exports:t)[s]=i[s]}}(window,(function(){return function(t){var e={};function i(s){if(e[s])return e[s].exports;var n=e[s]={i:s,l:!1,exports:{}};return t[s].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=e,i.d=function(t,e,s){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(s,n,function(e){return t[e]}.bind(null,n));return s},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=11)}([function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Util=void 0,e.Util={_id:0,id(){return this._id++},compositeId:(t,e)=>t<e?t+"."+e:e+"."+t,merge(t,e){if(t&&e)for(let i in e)"object"!=typeof e[i]||Array.isArray(e[i])||null===t[i]||void 0===t[i]?null===e[i]&&void 0===e[i]||void 0===t[i]||(t[i]=e[i]):this.merge(t[i],e[i])},extend(t,e){if(t&&e)for(let i in e)"object"!=typeof e[i]||Array.isArray(e[i])||null===t[i]||void 0===t[i]?null===e[i]&&void 0===e[i]||(t[i]=e[i]):this.extend(t[i],e[i])},remove(t,e){t.splice(t.findIndex(t=>t.id===e.id),1)},angle2Radian:t=>t/180*Math.PI,radian2Angle:t=>t/Math.PI*180,now:()=>window.performance.now(),insertSort(t,e){let i,s,n,o=t.length;for(i=1;i<o;i++){for(n=t[i],s=i-1;s>=0&&e(t[s],n)>0;s--)t[s+1]=t[s];t[s+1]=n}},clamp:(t,e,i)=>t<e?e:t>i?i:t,sign:t=>t<0?-1:1}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Vector=void 0;class s{constructor(t,e){void 0===t&&void 0===e?this.set(0,0):this.set(t,e)}set(t,e){this.x=t,this.y=e}add(t){return new s(this.x+t.x,this.y+t.y)}sub(t){return new s(this.x-t.x,this.y-t.y)}dot(t){return this.x*t.x+this.y*t.y}cro(t){return this.x*t.y-t.x*this.y}croNum(t){return new s(-t*this.y,t*this.x)}pro(t){return this.dot(t)/t.len()}nor(){return new s(-this.y,this.x)}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}len_s(){return this.x*this.x+this.y*this.y}nol(){let t=this.len();return 0!==t?new s(this.x/t,this.y/t):new s(0,0)}scl(t){return new s(t*this.x,t*this.y)}inv(){return new s(-this.x,-this.y)}eql(t){return this.x===t.x&&this.y===t.y}ang(t){return Math.acos(this.dot(t)/(this.len()*t.len()))}col(){return new s(this.x,this.y)}rot(t,e){e=e||new s(0,0);let i=Math.cos(t),n=Math.sin(t),o=this.sub(e),r=new s(0,0);return r.x=e.x+(o.x*i-o.y*n),r.y=e.y+(o.x*n+o.y*i),r}loc(t,e){return this.add(t.nol().scl(e))}}e.Vector=s},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Vertices=e.Poly=e.Vertex=void 0;const s=i(1),n=i(6),o=i(5),r=i(19),l=i(0);class a extends s.Vector{constructor(t){super(t.x,t.y)}}e.Vertex=a;class h{constructor(t,i){this.id=l.Util.id(),this.body=t,this.vertexList=i,this.parts=[],this.axes=e.Vertices.getAxes(i),this.center=e.Vertices.getCenter(i),this.bound=e.Vertices.getBound(i)}}e.Poly=h,e.Vertices={create:(t,e)=>new h(t,e),getCenter(t){let e=this.getRange(t),i=(e.max.x+e.min.x)/2,n=(e.max.y+e.min.y)/2;return new s.Vector(i,n)},getCentroid(t){let e,i,n=this.getArea(t),o=new s.Vector(0,0),r=0;for(let s=0;s<t.length;s++)i=(s+1)%t.length,r=t[s].cro(t[i]),e=t[s].add(t[i]).scl(r),o=o.add(e);return o.scl(1/(6*n))},getArea(t){let e=0,i=t.length-1;for(let s=0;s<t.length;s++)e+=(t[i].x-t[s].x)*(t[i].y+t[s].y),i=s;return e/2},getInertia(t,e){let i,s,n=0,o=0,r=t;for(let t=0;t<r.length;t++)s=(t+1)%r.length,i=Math.abs(r[s].cro(r[t])),n+=i*(r[s].dot(r[s])+r[s].dot(r[t])+r[t].dot(r[t])),o+=i;return e/6*(n/o)},getEdge(t){let e,i=[],s=t;for(let t=0;t<s.length;t++)e=(t+1)%s.length,i.push([s[t],s[e]]);return i},getAxes(t){let e=this.getEdge(t),i=null,s=[];for(let t=0;t<e.length;t++)i=e[t][1].sub(e[t][0]),s.push(i.nor().nol());return s},getRange(t){let e=t.map(t=>t.x),i=t.map(t=>t.y);return{min:new s.Vector(Math.min.apply(Math,e),Math.min.apply(Math,i)),max:new s.Vector(Math.max.apply(Math,e),Math.max.apply(Math,i))}},getBound(t){let i=e.Vertices.getRange(t);return new o.Bound(i.min,i.max)},getVelocityBound(t,i){let s=e.Vertices.getRange(t);return new r.VelocityBound(s.min,s.max,i)},uniqueAxes(t){let e,i,s,n=[],o={};for(i=0;i<t.length;i++)e=t[i],s=0===e.y?1/0:e.x/e.y,s=s.toFixed(3).toString(),o[s]=e;for(s in o)n.push(o[s]);return n},rotate(t,e,i){let s,n=t.vertexList,o=t.axes;for(s=0;s<n.length;s++){let t=n[s].rot(e,i);n[s].x=t.x,n[s].y=t.y}for(s=0;s<o.length;s++)o[s]=o[s].rot(e);if(t.center=t.center.rot(e,i),t.bound.update(t.vertexList),t.parts.length>1)for(s=0;s<t.parts.length;s++){let n=t.parts[s].center.rot(e,i);t.parts[s].center.x=n.x,t.parts[s].center.y=n.y,t.parts[s].bound.update(t.parts[s].vertexList)}},translate(t,e){let i,s=t.vertexList;for(i=0;i<s.length;i++)s[i].x+=e.x,s[i].y+=e.y;if(t.center.x+=e.x,t.center.y+=e.y,t.bound.translate(e),t.parts.length>1)for(i=0;i<t.parts.length;i++)t.parts[i].center.x+=e.x,t.parts[i].center.y+=e.y,t.parts[i].bound.translate(e)},divide(t){let i,s,n,o,r,l,a,h,c,d,u,p,f,m,g,y,v=[],x=t.vertexList.slice(0),b=t.axes.slice(0),w=x.length,A=!1;for(p=0;p<w;p++)if(m=p,g=(p+1)%w,y=(p+2)%w,a=x[g].sub(x[m]),h=x[y].sub(x[m]),a.cro(h)<0){for(f=p+3;f<w;f++)if(c=x[f].sub(x[m]),a.cro(c)>0){A=!0;break}if(A)break}return d=x[g],u=x[f],o=x.splice(y,f-y),n=x,o.unshift(d),o.push(u),l=b.splice(g,f-g),r=b,i=e.Vertices.create(t.body,n),s=e.Vertices.create(t.body,o),i.axes=r,s.axes=l,this.isConcave(n)?v=v.concat(this.divide(i)):v.push(i),this.isConcave(o)?v=v.concat(this.divide(s)):v.push(s),v},decomposition(t){let i,s,o,r,l,a,h,c=t.vertexList,d=c.slice(0),u=[],p=[],f=[],m=[],g=null;if(d.length<=4)return[t];for(u=this.findCaves(c);!(d.length<3);){for(h=1;h<d.length&&(i=h,s=h-1,o=(h+1)%d.length,r=d[i],l=d[s],a=d[o],p=[l,r,a],!(0===u.length||u.indexOf(r)<0&&!u.some(t=>this.isContains(p,t))));h++);n.Lines.isIntersectWithVertices([l,r],c)||f.push(t.axes[s]),n.Lines.isIntersectWithVertices([r,a],c)||f.push(t.axes[i]),n.Lines.isIntersectWithVertices([l,a],c)||f.push(t.axes[o]),g=e.Vertices.create(t.body,p),g.axes=f,m.push(g),d.splice(i,1),p=[],f=[]}return m},intersection(t,e){let i,s,o=[];for(i=0;i<t.length;i++)for(s=0;s<e.length;s++)if(n.Lines.isIntersect(t[i],e[s])&&(o.push(n.Lines.intersection(t[i],e[s])),o.length>=2))return o;return o},isContains(t,e){let i,s,n=t,o=t.length,r=!1;for(i=0,s=o-1;i<o;s=i++){if(n[i].eql(e))return!1;n[i].y>e.y!=n[s].y>e.y&&e.x<(n[s].x-n[i].x)*(e.y-n[i].y)/(n[s].y-n[i].y)+n[i].x&&(r=!r)}return r},isConcave(t){let e,i,s,n,o,r,l,a=t,h=a.length;for(o=1;o<h;o++){if(r=o-1,l=(o+1)%h,s=a[o].sub(a[r]),n=a[l].sub(a[o]),i=s.cro(n)>=0?1:-1,void 0!==e&&e!==i)return!0;e=i}return!1},transform2World:(t,e)=>e.map(e=>{let{x:i,y:s}=e.add(t);return e.x=i,e.y=s,e}),transform2Local:(t,e)=>e.map(e=>{let{x:i,y:s}=e.sub(t);return e.x=i,e.y=s,e}),projection(t,e){let i=t.map(t=>t.pro(e));return{min:Math.min.apply(Math,i),max:Math.max.apply(Math,i)}},getClosestVertex(t,e){let i,s,n,o=e,r=1/0,l=o.length;for(i=0;i<l;i++)s=o[i].sub(t).len(),s<r&&(r=s,n=i);return e[n]},findCaves(t){let e,i,s,n,o=[],r=t,l=r.length;for(n=1;n<l;n++)e=r[n-1],i=r[n],s=r[(n+1)%l],i.sub(e).cor(s.sub(i))<0&&o.push(i);return o}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Event=void 0;e.Event=new class{bind(t,e,i){t.methods[e]=i}unBind(t,e){t.methods[e]=null}emit(t,e,...i){t.methods[e]&&"function"==typeof t.methods[e]&&t.methods[e](...i)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Arcs=e.Arc=void 0;const s=i(1),n=i(7),o=i(2),r=i(5);class l{constructor(t,i,s){this.id=t.id,this.body=t,this.center=i,this.radius=s,this.bound=e.Arcs.getBound(i,s)}}e.Arc=l,e.Arcs={tempMatrix:n.Matrix,create:t=>new l(t,t.position.col(),t.radius),distance:(t,e)=>t.center.sub(e.center).len(),getAxes:(t,e)=>[o.Vertices.getClosestVertex(t.center,e.vertexList).sub(t.center).nol()],getBound(t,e){let i=new s.Vector(t.x-e,t.y-e),n=new s.Vector(t.x+e,t.y+e);return new r.Bound(i,n)},Projection(t,e){let i=t.center.pro(e);return{min:i-t.radius,max:i+t.radius}},isContains:(t,e)=>t.radius*t.radius-t.center.sub(e).len_s()>0,translate(t,e){t.center.x+=e.x,t.center.y+=e.y,t.bound.translate(e)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Bound=void 0;const s=i(2);e.Bound=class{constructor(t,e){this.set(t,e)}set(t,e){this.min=t,this.max=e}translate(t){this.set(this.min.add(t),this.max.add(t))}update(t){let e=s.Vertices.getRange(t);this.set(e.min,e.max)}isIntersect(t){return this.min.x<t.max.x&&this.max.x>t.min.x&&this.min.y<t.max.y&&t.min.y<this.max.y}isContains(t){return t.x>this.min.x&&t.x<this.max.x&&t.y>this.min.y&&t.y<this.max.y}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Lines=void 0,e.Lines={side(t,e){let i=t[1].sub(t[0]),s=e.sub(t[0]).cro(i);return 0===s?s:s<0?-1:1},isIntersect(t,e){let i=t[0],s=t[1],n=e[0],o=e[1];return this.side(t,n)!==this.side(t,o)&&this.side(e,i)!==this.side(e,s)},isIntersectWithVertices(t,e){let i,s,n,o=e.length;for(n=0;n<o;n++)if(i=this.side(t,e[n]),0!==i){if(s&&s!==i)return!0;s=i}return!1},intersection(t,e){let i=t[1].sub(t[0]),s=e[1].sub(e[0]),n=t[0].sub(e[0]),o=t[1].sub(e[1]),r=Math.abs(n.cro(i)/i.len()),l=Math.abs(o.cro(i)/i.len()),a=s.scl(r/(r+l));return e[0].add(a)},projection(t,e){let i=t[0].pro(e),s=t[1].pro(e);return i>s?{min:s,max:i}:{min:i,max:s}}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Matrix=void 0;const s=i(1);class n{constructor(t,e){void 0===t&&void 0===e&&(t=new s.Vector(1,0),e=new s.Vector(0,1)),this.set(t,e)}set(t,e){this.row1=t,this.row2=e,this.col1=new s.Vector(this.row1.x,this.row2.x),this.col2=new s.Vector(this.row1.y,this.row2.y)}rot(t){let e=Math.cos(t),i=Math.sin(t);this.row1.set(e,-i),this.row2.set(i,e)}mul(t){if(t instanceof n){let e=new s.Vector(this.row1.dot(t.col1),this.row1.dot(t.col2)),i=new s.Vector(this.row2.dot(t.col1),this.row2.dot(t.col2));return new n(e,i)}return t instanceof s.Vector?new s.Vector(this.row1.dot(t),this.row2.dot(t)):new n(this.row1.scl(t),this.row2.scl(t))}trp(){return new n(this.col1,this.col2)}}e.Matrix=n},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Manifold=e.Collision=e.Contact=void 0;const s=i(0);e.Contact=class{constructor(t){this.vertex=t,this.shareNormal=0,this.shareTangent=0,this.inverseMass=0,this.normalImpulse=0,this.tangentImpulse=0,this.bias=0}};e.Collision=class{};e.Manifold=class{constructor(t,e){this.bodyA=t.bodyA,this.bodyB=t.bodyB,this.partA=t.partA,this.partB=t.partB,this.id=s.Util.compositeId(this.partA.id,this.partB.id),this.collision=t,this.contacts=t.contacts,this.isActive=!0,this.confirmedActive=!0,this.timeCreated=e,this.timeUpdated=e,this.friction=0,this.restitution=0,this.inverseMass=0,this.update(t,e)}update(t,e){if(this.collision=t,t.collide){let i,s;i=t.bodyA,s=t.bodyB,this.friction=Math.sqrt(i.friction*s.friction),this.restitution=(i.restitution+s.restitution)/2,this.inverseMass=i.invMass+s.invMass,this.contacts=t.contacts,this.toggleActive(!0,e)}else this.isActive&&this.toggleActive(!1,e)}toggleActive(t,e){this.isActive=t,t?this.timeUpdated=e:this.contacts=[]}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Body=e.bodyType=void 0;const s=i(1),n=i(0),o=i(3);!function(t){t[t.circle=0]="circle",t[t.polygon=1]="polygon",t[t.capsule=2]="capsule",t[t.composite=3]="composite"}(e.bodyType||(e.bodyType={}));e.Body=class{constructor(t,e){this.id=n.Util.id(),this.type=e,this.engine=null,this.data=null,this.origin=new s.Vector(0,0),this.position=new s.Vector(0,0),this.rotation=0,this.velocity=new s.Vector(0,0),this.angularVelocity=0,this.speed=0,this.angularSpeed=0,this.motion=0,this.mass=10,this.area=0,this.density=1,this.inertia=0,this.invInertia=0,this.force=new s.Vector(0,0),this.torque=0,this.friction=.4,this.restitution=1,this.constraint=null,this.fixed=!1,this.sleeping=!1,this.sleepCounter=0,this.mask=1,this.parts=[],this.bound=null,this.collisionNum=0,this.methods={filter:(t,e)=>!0,beforeAppend:t=>{},afterAppend:t=>{},beforeRemove:t=>{},afterRemove:t=>{},sleepStart:t=>{},sleepEnd:t=>{}},n.Util.extend(this,t),this.fixed&&(this.sleeping=!0),this.area=this.getArea(),this.density=this.getDensity(),this.invMass=this.getInvMass(),this.inertia=this.getInertia(),this.invInertia=this.getInvInertia(),this.position=this.getCentroid(),this.speed=this.velocity.len(),this.angularSpeed=Math.abs(this.angularVelocity),this.motion=this.speed*this.speed+this.angularSpeed*this.angularSpeed,this.setRender(()=>{})}getInvMass(){return 0===this.mass||this.fixed?0:1/this.mass}getInvInertia(){return 0===this.inertia||this.fixed?0:1/this.inertia}getDensity(){return this.mass/this.area}getArea(){return 1}getCentroid(){return null}getInertia(){return 1}getBound(){return null}setData(t){null!=t&&(this.data=t)}setEngine(t){this.engine=t}setRender(t){t&&"function"==typeof t&&(this.render=t)}translate(t){}rotate(t,e){}collide(t){this.collisionNum++,o.Event.emit(this,"collide",this,t)}separate(){this.collisionNum--,0===this.collisionNum&&o.Event.emit(this,"isolate",this)}applyImpulse(t,e){this.velocity.x+=t.x*this.invMass,this.velocity.y+=t.y*this.invMass,this.angularVelocity+=this.invInertia*e.cro(t)}applyForce(t,e){this.force.x+=t.x,this.force.y+=t.y,void 0!==e&&(this.torque+=e.cro(this.force))}integrateForces(t){this.fixed||this.sleeping||(this.velocity.x+=t*this.force.x*this.invMass,this.velocity.y+=t*this.force.y*this.invMass,this.angularVelocity+=t*this.torque*this.invInertia)}integrateVelocities(t){if(this.fixed||this.sleeping)return;let e=t*this.velocity.x,i=t*this.velocity.y,n=t*this.angularVelocity;this.position.x+=e,this.position.y+=i,this.rotation+=n,this.translate(new s.Vector(e,i)),0!==this.angularVelocity&&this.rotate(n,this.position),this.speed=this.velocity.len(),this.angularSpeed=Math.abs(this.angularVelocity),this.motion=this.speed*this.speed+this.angularSpeed*this.angularSpeed,this.force.x=0,this.force.y=0,this.torque=0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Polygon=void 0;const s=i(9),n=i(2);class o extends s.Body{constructor(t,e){super(t,e||s.bodyType.polygon),t.vertices&&(this.vertexList=t.vertices.map(t=>new n.Vertex(t))),this.vertexList&&this.vertexList.length<3||(this.parts=this.getParts(),this.rotation&&this.rotate(this.rotation,this.position))}getPoly(){return n.Vertices.create(this,n.Vertices.transform2World(this.origin,this.vertexList))}getArea(){return Math.abs(n.Vertices.getArea(this.vertexList))}getCentroid(){return n.Vertices.getCentroid(this.vertexList).add(this.origin)}getInertia(){return n.Vertices.getInertia(this.vertexList,this.mass)}translate(t){this.origin.x+=t.x,this.origin.y+=t.y,this.parts.map(e=>n.Vertices.translate(e,t))}rotate(t,e){this.parts.map(i=>n.Vertices.rotate(i,t,e))}getParts(){let t=[],e=this.getPoly();return n.Vertices.isConcave(e.vertexList)?(t=n.Vertices.divide(e),t):(t=[e],t.map(t=>{t.parts=n.Vertices.decomposition(t)}),this.bound=e.bound,t)}}e.Polygon=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Torque=void 0;const s=i(12),n=i(24),o=i(0),r=i(2),l=i(6),a=i(4),h=i(1),c=i(7);s.TorqueWorld.body=new n.BodiesFactory,s.TorqueWorld.util=o.Util,s.TorqueWorld.math={vector:(t,e)=>new h.Vector(t,e),matrix:(t,e)=>new c.Matrix(t,e)},s.TorqueWorld.geometry={vertex:r.Vertex,line:l.Lines,arcs:a.Arcs},e.Torque=s.TorqueWorld},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TorqueWorld=void 0;const s=i(0),n=i(13),o=i(3);e.TorqueWorld=class{constructor(t,e,i){this.engine=new n.Engine(t,e,i)}append(t){Array.isArray(t)?t.map(t=>this.append(t)):(o.Event.emit(t,"beforeAppend",t),t.setEngine(this.engine),this.engine.bodies.push(t),o.Event.emit(t,"afterAppend",t))}remove(t){o.Event.emit(t,"beforeRemove",t),s.Util.remove(this.engine.bodies,t),o.Event.emit(t,"afterRemove",t)}clear(){this.engine.bodies.map(t=>this.remove(t)),this.engine.manifoldTable.clear()}clone(t){return null}setEngineOption(t){this.engine.setOption(t)}step(t){this.engine.timeStepper.addStep(t)}start(t){this.engine.timeStepper.start(t)}pause(){this.engine.timeStepper.pause()}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Engine=void 0;const s=i(1),n=i(0),o=i(14),r=i(15),l=i(20),a=i(22),h=i(23),c=i(3);e.Engine=class{constructor(t,e,i){this.width=t||0,this.height=e||0,this.gravity=new s.Vector(0,8),this.enableSleeping=!0,this.enableColllisionDetection=!0,this.enableCollisionResolve=!0,this.methods={onTickStart:()=>{},onTickEnd:()=>{},beforeUpdate:()=>{},afterUpdate:()=>{},beforeRender:()=>{},afterRender:()=>{},onStart:()=>{},onPause:()=>{},collisionStart:t=>{},collisionActive:t=>{},collisionEnd:t=>{}},n.Util.merge(this,i),this.bodies=[],this.timeStepper=new o.TimeStepper(this,i),this.detector=new r.Detector(this,i),this.manifoldTable=new h.ManifoldTable(i),this.resolver=new l.Resolver(this,i),this.sleeping=new a.Sleeping(i)}update(t,e){let i=[],s=[];this.enableSleeping&&this.sleeping.update(this.bodies);for(let e=0;e<this.bodies.length;e++)this.bodies[e].applyForce(this.gravity.scl(this.bodies[e].mass)),this.bodies[e].integrateForces(t);this.resolver.solveConstraint(),this.enableColllisionDetection&&(i=this.detector.broadPhase.detect(this.bodies),s=this.detector.narrowPhase.detect(i),this.manifoldTable.update(s,e),this.manifoldTable.filter(e),this.enableCollisionResolve&&(this.enableSleeping&&this.sleeping.afterCollision(this.manifoldTable.list),this.resolver.solveCollision(this.manifoldTable.list,t)));for(let e=0;e<this.bodies.length;e++)this.bodies[e].integrateVelocities(t);this.manifoldTable.collisionStart.length&&c.Event.emit(this,"collisionStart",this.manifoldTable.collisionStart),this.manifoldTable.collisionActive.length&&c.Event.emit(this,"collisionActive",this.manifoldTable.collisionActive),this.manifoldTable.collisionEnd.length&&c.Event.emit(this,"collisionEnd",this.manifoldTable.collisionEnd)}render(t){for(let e=0;e<this.bodies.length;e++)this.bodies[e].render(this.bodies[e],t)}setOption(t){n.Util.merge(this,t),n.Util.merge(this.timeStepper,t),n.Util.merge(this.manifoldTable,t),n.Util.merge(this.resolver,t)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TimeStepper=void 0;const s=i(0),n=i(3);e.TimeStepper=class{constructor(t,e){this.engine=t,this.status=!1,this.tickProcessorList=[],this.fps=e.fps||60,this.deltaFixed=void 0===e.deltaFixed||e.deltaFixed,this.deltaRecordLimit=60,s.Util.merge(this,e),this.dt=1/this.fps,this.dtMin=this.dt,this.dtMax=2*this.dt,this.frameCounter=0,this.frameStamp=0,this.prevTime=0,this.frameTotal=0,this.frameNumLimit=-1,this.deltaRecorder=[]}tick(t=0){let e;!1===this.deltaFixed&&(e=t-this.prevTime||this.dt,this.prevTime=t,this.deltaRecorder.push(e),this.deltaRecorder=this.deltaRecorder.slice(-this.deltaRecordLimit),e=s.Util.clamp(Math.min.apply(Math,this.deltaRecorder),this.dtMin,this.dtMax),this.dt=e),this.frameCounter+=1,t-this.frameStamp>=1e3&&(this.fps=this.frameCounter*((t-this.frameStamp)/1e3),this.frameStamp=t,this.frameCounter=0),n.Event.emit(this.engine,"onTickStart"),n.Event.emit(this.engine,"beforeUpdate"),this.engine.update(this.dt,t),n.Event.emit(this.engine,"afterUpdate"),n.Event.emit(this.engine,"beforeRender"),this.engine.render(this.dt),n.Event.emit(this.engine,"afterRender"),this.tickProcessorList.map(e=>e(t)),n.Event.emit(this.engine,"onTickEnd"),this.frameTotal++,this.frameNumLimit>0&&this.frameTotal>=this.frameNumLimit?this.pause():this.raf=window.requestAnimationFrame(this.tick.bind(this))}addStep(t){"function"==typeof t&&this.tickProcessorList.push(t)}start(t){this.status||(t&&t>0&&(this.frameNumLimit=t),this.status=!0,n.Event.emit(this.engine,"onStart"),this.tick())}pause(){this.status&&(this.status=!1,this.frameTotal=0,n.Event.emit(this.engine,"pause"),window.cancelAnimationFrame(this.raf))}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Detector=void 0;const s=i(16),n=i(17);e.Detector=class{constructor(t,e){this.broadPhase=new s.BroadPhase(t),this.narrowPhase=new n.NarrowPhase(t)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BroadPhase=void 0;const s=i(0);e.BroadPhase=class{constructor(t){this.engine=t}detect(t){return this.sweepAndPrune(t)}isBodyOutWindow(t){return t.max.y<0||t.min.x>this.engine.width||t.min.y>this.engine.height||t.max.x<0}canCollide(t,e){return!(!t.methods.filter(t.mask,e.mask)||!e.methods.filter(e.mask,t.mask))&&(!this.isBodyOutWindow(t.bound)&&!this.isBodyOutWindow(e.bound)&&((!t.fixed||!e.fixed)&&(!t.sleeping||!e.sleeping)))}sweepAndPrune(t){let e,i,n=[],o=t.length;for(s.Util.insertSort(t,(t,e)=>t.bound.min.x-e.bound.min.x),e=0;e<o;e++)for(i=e+1;i<o&&!(t[e].bound.max.x<t[i].bound.min.x);i++)this.canCollide(t[e],t[i])&&t[e].bound.isIntersect(t[i].bound)&&n.push({bodyA:t[e],bodyB:t[i]});return n}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.NarrowPhase=void 0;const s=i(18),n=i(4),o=i(2),r=i(0);e.NarrowPhase=class{constructor(t){this.engine=t,this.SAT=new s.SAT}detect(t){let e,i,s,r,l,a,h,c,d=[],u=null;for(a=0;a<t.length;a++)for(e=t[a],i=e.bodyA.parts,s=e.bodyB.parts,h=0;h<i.length;h++)for(r=i[h],c=0;c<i.length;c++)l=s[c],r.bound.isIntersect(l.bound)&&(u=this.getPrevCollision(r,l,this.engine.manifoldTable),r instanceof n.Arc&&l instanceof n.Arc?d.push(this.SAT.circleCollideCircle(r,l,u)):r instanceof o.Poly&&l instanceof n.Arc?d.push(this.SAT.polygonCollideBody(r,l,u)):r instanceof n.Arc&&l instanceof o.Poly?d.push(this.SAT.polygonCollideBody(l,r,u)):d.push(this.SAT.polygonCollideBody(r,l,u)));return d}getPrevCollision(t,e,i){let s=r.Util.compositeId(t.id,e.id),n=i.table[s];return this.engine.manifoldTable.enableCache&&n&&n.isActive?n.collision:null}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SAT=void 0;const s=i(2),n=i(4),o=i(8);e.SAT=class{polygonCollideBody(t,e,i){let s=null,n=null,r=null;if(this.canReuseCollision(t,e,i)){if(s=i,r=i.contacts,n=this.detect(t,e,[s.normal]),n.minOverlap<0)return s.collide=!1,s}else{let i=this.filterAxes(t,e);if(s=new o.Collision,n=this.detect(t,e,i),n.minOverlap<0)return s.collide=!1,s;s.normal=this.reviseNormal(i[n.index],t,e),s.partA=t,s.partB=e,s.bodyA=t.body,s.bodyB=e.body,s.tangent=s.normal.nor()}if(s.depth=n.minOverlap,s.penetration=s.normal.scl(s.depth),s.contacts=this.findContacts(t,e,s.normal,s.depth),s.collide=!0,r)for(let t=0;t<r.length;t++)s.contacts[t]&&(s.contacts[t].normalImpulse=r[t].normalImpulse,s.contacts[t].tangentImpulse=r[t].tangentImpulse);return s}circleCollideCircle(t,e,i){let n=t.center.sub(e.center),r=0,l=null;return l=new o.Collision,n=t.center.sub(e.center),r=t.radius+e.radius-n.len(),r<0?(l.collide=!1,l):(l.partA=t,l.partB=e,l.bodyA=t.body,l.bodyB=e.body,l.normal=this.reviseNormal(n,t,e).nol(),l.tangent=l.normal.nor().nol(),l.depth=r,l.penetration=l.normal.scl(r),l.contacts=[new o.Contact(new s.Vertex(t.center.loc(l.normal.inv(),t.radius-r/2)))],l.collide=!0,l)}detect(t,e,i){let s,n,o,r=1/0,l=i.length;for(n=0;n<l;n++){if(s=this.minOverlaps(t,e,i[n]),s<0)return{minOverlap:s,index:o};s<r&&(r=s,o=n)}return{minOverlap:r,index:o}}filterAxes(t,e){let i,o,r,l,a=[],h=t.parts,c=null;if(e instanceof s.Poly){if(c=e.parts,h.length&&c.length)for(r=0;r<h.length;r++)for(i=h[r],l=0;l<c.length;l++)o=c[l],i.bound.isIntersect(o.bound)&&(a=a.concat(i.axes),a=a.concat(o.axes))}else{for(r=0;r<h.length;r++)i=h[r],h[r].bound.isIntersect(e.bound)&&(a=a.concat(i.axes));a=a.concat(n.Arcs.getAxes(e,t))}return s.Vertices.uniqueAxes(a)}reviseNormal(t,e,i){return t.dot(i.center.sub(e.center))>0?t.inv():t}minOverlaps(t,e,i){let o,r;return e instanceof s.Poly?(o=s.Vertices.projection(t.vertexList,i),r=s.Vertices.projection(e.vertexList,i)):(o=s.Vertices.projection(t.vertexList,i),r=n.Arcs.Projection(e,i)),Math.min(o.max-r.min,r.max-o.min)}findContacts(t,e,i,n){let r,l=[],a=[],h=[],c=i.inv();if(e instanceof s.Poly){let n=t.vertexList,d=e.vertexList;for(l=this.orderProjectionVertexInNormalDirection(n,i),r=0;r<l.length;r++)if(s.Vertices.isContains(d,l[r]))h.push(new o.Contact(l[r]));else if(0!==r)break;if(h.length>=2)return h;for(a=this.orderProjectionVertexInNormalDirection(d,c),r=0;r<a.length;r++)if(s.Vertices.isContains(n,a[r]))h.push(new o.Contact(a[r]));else if(0!==r)break;h.length<1&&h.push(new o.Contact(l[0]))}else h.push(new o.Contact(new s.Vertex(e.center.loc(i,e.radius-n/2))));return h}orderProjectionVertexInNormalDirection(t,e){return t.slice(0).sort((t,i)=>t.dot(e)-i.dot(e))}canReuseCollision(t,e,i){if(i){let s=t.body,n=e.body,o=s.speed**2+s.angularSpeed**2+n.speed**2+n.angularSpeed**2;return i.collide&&o<.011}return!1}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.VelocityBound=void 0;const s=i(5);class n extends s.Bound{constructor(t,e,i){super(t,e),this.velocity=i}set(t,e){this.min=t,this.max=e,this.velocity.x>0?this.max.x+=this.velocity.x:this.min.x+=this.velocity.x,this.velocity.y>0?this.max.y+=this.velocity.y:this.min.y+=this.velocity.y}}e.VelocityBound=n},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Resolver=void 0;const s=i(0),n=i(21);e.Resolver=class{constructor(t,e){this.engine=t,this.velocityIterations=10,this.constraintIterations=6,this.slop=.02,this.biasFactor=.3,this.collisionSolver=new n.CollisionSolver(this),s.Util.merge(this,e)}solveCollision(t,e){this.collisionSolver.preSolveVelocity(t,e);for(let i=0;i<this.velocityIterations;i++)this.collisionSolver.solveVelocity(t,e)}solveConstraint(){}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CollisionSolver=void 0;const s=i(1),n=i(0);e.CollisionSolver=class{constructor(t){this.resolver=t}preSolveVelocity(t,e){let i,n,o,r,l,a,h,c,d,u;for(d=0;d<t.length;++d)if(i=t[d],i.isActive)for(n=i.collision,a=n.normal,h=n.tangent,r=n.bodyA,l=n.bodyB,c=i.contacts.length,u=0;u<n.contacts.length;u++){o=n.contacts[u],o.offsetA=o.vertex.sub(r.position),o.offsetB=o.vertex.sub(l.position);let t=i.inverseMass,d=i.inverseMass,p=o.offsetA,f=o.offsetB,m=o.offsetA.dot(a),g=o.offsetB.dot(a),y=o.offsetA.dot(h),v=o.offsetB.dot(h);t+=r.invInertia*(p.dot(p)-m*m),t+=l.invInertia*(f.dot(f)-g*g),d+=r.invInertia*(p.dot(p)-y*y),d+=l.invInertia*(f.dot(f)-v*v),o.shareNormal=1/(t*c),o.shareTangent=1/(d*c),o.bias=1*this.resolver.biasFactor/e*Math.max(0,n.depth+this.resolver.slop);let x=o.normalImpulse,b=o.tangentImpulse,w=new s.Vector;0===x&&0===b||(w.x=a.x*x+h.x*b,w.y=a.y*x+h.y*b,!r.sleeping&&r.applyImpulse(w,o.offsetA),!l.sleeping&&l.applyImpulse(w.inv(),o.offsetB))}}solveVelocity(t,e){let i,s,o,r,l,a,h,c,d,u,p,f,m,g;for(m=0;m<t.length;m++)if(i=t[m],i.isActive)for(s=i.collision,a=s.normal,h=s.tangent,r=s.bodyA,l=s.bodyB,g=0;g<s.contacts.length;g++){o=s.contacts[g];let t=r.velocity.add(o.offsetA.croNum(r.angularVelocity)),e=l.velocity.add(o.offsetB.croNum(l.angularVelocity)),m=e.sub(t);p=a.dot(m),c=i.restitution*(p+o.bias)*o.shareNormal;let y=o.normalImpulse;o.normalImpulse=Math.max(o.normalImpulse+c,0),c=o.normalImpulse-y,!r.sleeping&&r.applyImpulse(a.scl(c),o.offsetA),!l.sleeping&&l.applyImpulse(a.scl(-c),o.offsetB),t=r.velocity.add(o.offsetA.croNum(r.angularVelocity)),e=l.velocity.add(o.offsetB.croNum(l.angularVelocity)),m=e.sub(t),f=h.dot(m),d=f*o.shareTangent,u=i.friction*o.normalImpulse;let v=o.tangentImpulse;o.tangentImpulse=n.Util.clamp(o.tangentImpulse+d,-u,u),d=o.tangentImpulse-v,!r.sleeping&&r.applyImpulse(h.scl(d),o.offsetA),!l.sleeping&&l.applyImpulse(h.scl(-d),o.offsetB)}}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Sleeping=void 0;const s=i(0),n=i(3);e.Sleeping=class{constructor(t){this.sleepThreshold=60,this.sleepMotionThreshold=1e-5,this.wakeMotionThreshold=.008,s.Util.merge(this,t)}sleep(t){t.sleeping=!0,t.sleepCounter=this.sleepThreshold,t.velocity.x=0,t.velocity.y=0,t.angularVelocity=0,t.speed=0,t.angularSpeed=0,t.motion=0,n.Event.emit(t,"sleepStart",t)}wake(t){t.sleeping=!1,t.sleepCounter=0,n.Event.emit(t,"sleepEnd",t)}update(t){let e,i;for(i=0;i<t.length;i++){if(e=t[i],e.fixed)continue;let s=e.velocity.len()*e.velocity.len()+Math.abs(e.angularVelocity)*Math.abs(e.angularVelocity);0===e.force.x&&0===e.force.y?e.sleeping||(s<this.sleepMotionThreshold?(e.sleepCounter+=1,e.sleepCounter>=this.sleepThreshold&&this.sleep(e)):e.sleepCounter>0&&(e.sleepCounter-=1)):this.wake(e)}}afterCollision(t){let e,i,s;for(var n=0;n<t.length;n++)e=t[n],i=e.bodyA,s=e.bodyB,!i.fixed&&i.sleeping&&s.motion>this.wakeMotionThreshold?this.wake(i):!s.fixed&&s.sleeping&&i.motion>this.wakeMotionThreshold&&this.wake(s)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ManifoldTable=void 0;const s=i(8),n=i(0);e.ManifoldTable=class{constructor(t){this.enableCache=!0,this.enableManifoldRemove=!0,this.manifoldRemoveThreshold=1e3,this.table={},this.list=[],this.collisionStart=[],this.collisionEnd=[],this.collisionActive=[],n.Util.merge(this,t)}update(t,e){let i,o,r,l;for(this.collisionStart.length=0,this.collisionEnd.length=0,this.collisionActive.length=0,l=0;l<this.list.length;l++)this.list[l].confirmedActive=!1;for(l=0;l<t.length;l++)r=t[l],r.collide&&(o=n.Util.compositeId(r.partA.id,r.partB.id),i=this.table[o],i?(i.isActive?this.collisionActive.push(i):this.collisionStart.push(i),i.update(r,e),i.confirmedActive=!0):(i=new s.Manifold(r,e),this.table[o]=i,this.list.push(i),this.collisionStart.push(i)));for(l=0;l<this.list.length;l++)i=this.list[l],i.isActive&&!i.confirmedActive&&(i.toggleActive(!1,e),this.collisionEnd.push(i))}filter(t){let e,i;for(i=0;i<this.list.length;i++)e=this.list[i],e.bodyA.sleeping||e.bodyB.sleeping?e.timeUpdated=t:t-e.timeUpdated>this.manifoldRemoveThreshold&&(delete this.table[e.id],this.list.splice(i,1),i--)}clear(){this.table={},this.list.length=0,this.collisionStart.length=0,this.collisionEnd.length=0,this.collisionActive.length=0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BodiesFactory=void 0;const s=i(25),n=i(10),o=i(26),r=i(1),l=i(0);e.BodiesFactory=class{Circle(t,e,i,n){return n=n||{},l.Util.extend(n,{origin:new r.Vector(t,e),radius:i}),new s.Circle(n)}Polygon(t,e,i,s){s=s||{};let o=i.map(t=>new r.Vector(t[0],t[1]));return l.Util.extend(s,{origin:new r.Vector(t,e),vertices:o}),new n.Polygon(s)}Rect(t,e,i,s,n){return n=n||{},l.Util.extend(n,{origin:new r.Vector(t,e),width:i,height:s}),new o.Rect(n)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Circle=void 0;const s=i(9),n=i(4);class o extends s.Body{constructor(t){super(t,s.bodyType.circle);let e=this.getArc();this.parts=[e],this.bound=e.bound}getArea(){return Math.PI*this.radius*this.radius}getCentroid(){return this.origin.col()}getInertia(){return.5*this.mass*Math.pow(this.radius,2)}getArc(){return n.Arcs.create(this)}translate(t){this.origin.x+=t.x,this.origin.y+=t.y,this.parts.map(e=>n.Arcs.translate(e,t))}}e.Circle=o},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Rect=void 0;const s=i(10),n=i(1),o=i(2);class r extends s.Polygon{constructor(t){super(t)}getPoly(){let t=this.origin.col(),e=t.add(new n.Vector(this.width,0)),i=t.add(new n.Vector(this.width,this.height)),s=t.add(new n.Vector(0,this.height)),r=o.Vertices.create(this,[t,e,i,s].map(t=>new o.Vertex(t)));return r.axes=o.Vertices.uniqueAxes(r.axes),r}getArea(){return this.width*this.height}getCentroid(){return this.origin.add(new n.Vector(this.width/2,this.height/2))}getInertia(){return this.mass*(this.width*this.width+this.height*this.height)/12}}e.Rect=r}])}));